import com.google.gson.Gson
import com.google.gson.reflect.TypeToken
import java.io.File

fun main() {
    val usageType = askUserForInputType()
    when (usageType) {
        UsageType.MANUAL -> {
            val userInputFileAddress =
                getDirectory("resources") + getUserInput("Enter the path of the .json as an input file (e.g., input.json):")
            val file = File(userInputFileAddress)

            if (!file.exists() || !file.isFile) {
                println("The file does not exist or is not a file. Please try again.")
                return
            }

            val inputFile = readFromFile(userInputFileAddress) ?: return
            val services: List<Service> = Gson().fromJson(inputFile, object : TypeToken<List<Service>>() {}.type)
            val newServices = services.onEach { service ->
                when (service.type?.lowercase()) {
                    ServiceType.WORDPRESS.toString().lowercase() -> {
                        service.version = getWordPressVersion(url = service.url)["version"]
                        service.version?.let { version ->
                            service.type.let { type ->
                                val vulnerabilities = fetchAllVulnerabilities(
                                    serviceVendor = type,
                                    serviceType = type,
                                    serviceVersion = version
                                )
                                printVulnerabilities(
                                    serviceUrl = service.url,
                                    serviceType = type,
                                    serviceVersion = version,
                                    vulnerabilities = vulnerabilities
                                )
                            }
                        }
                    }

                    ServiceType.MYSQL.toString().lowercase() -> {
                        service.version = getMySQLVersion()
                        service.version?.let { version ->
                            service.type.let { type ->
                                val vulnerabilities = fetchAllVulnerabilities(
                                    serviceVendor = type,
                                    serviceType = type,
                                    serviceVersion = version
                                )
                                printVulnerabilities(
                                    serviceUrl = service.url,
                                    serviceType = type,
                                    serviceVersion = version,
                                    vulnerabilities = vulnerabilities
                                )
                            }
                        }
                    }

                    ServiceType.APACHE.toString().lowercase() -> {
                        service.version = getApacheVersion()
                        service.version?.let { version ->
                            service.type.let { type ->
                                val vulnerabilities = fetchAllVulnerabilities(
                                    serviceVendor = type,
                                    serviceType = type,
                                    serviceVersion = version
                                )
                                printVulnerabilities(
                                    serviceUrl = service.url,
                                    serviceType = type,
                                    serviceVersion = version,
                                    vulnerabilities = vulnerabilities
                                )
                            }
                        }
                    }

                    else -> {
                        println("Service type is not supported. Supported service types are: WORDPRESS, MYSQL, APACHE.")
                    }
                }
            }

            writeToFile(userInputFileAddress, kotlinObjectToJson(newServices))
        }

        UsageType.DOCKER -> {
            val outputFileAddress = getDirectory("resources") + "network_services.json"
            if (!isProcessExecutionSuccessful() || !checkDockerDaemonStatus()) {
                println("Docker daemon is not running. Please start Docker daemon and try again.")
                return
            }

            showDockerNetworks()
            val networkName = getUserInput("Enter your desired network name to scan for possible vulnerabilities:")
            if (!checkIfDockerNetworkNameIsCorrect(networkName)) {
                println("Network name is incorrect. Rerun the program and enter a valid network name.")
                return
            }

            startDockerContainers(networkName)
            val serviceDetailsList = getServiceDetailsFromNetwork(networkName)
            if (serviceDetailsList.isEmpty()) {
                println("There is no service running in the network.")
                writeToFile(
                    outputFileAddress,
                    Gson().toJson(mapOf("message" to "There is no running service in the network."))
                )
                return
            }

            writeToFile(outputFileAddress, kotlinObjectToJson(serviceDetailsList))
            serviceDetailsList.forEach { serviceDetails ->
                val vulnerabilities = fetchAllVulnerabilities(
                    serviceDetails.serviceVendor,
                    serviceDetails.serviceType!!,
                    serviceDetails.serviceVersion
                )
                printVulnerabilities(
                    serviceType = serviceDetails.serviceType,
                    serviceVersion = serviceDetails.serviceVersion,
                    vulnerabilities = vulnerabilities
                )
            }
            stopDockerContainers(networkName)
        }

        else -> {
            println("Usage Type is not correct, Try again.")
            return
        }
    }

}