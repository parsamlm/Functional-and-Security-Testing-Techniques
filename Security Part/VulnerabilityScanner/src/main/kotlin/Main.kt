fun main() {

    val process = Runtime.getRuntime().exec(arrayOf("bash", "-c", "docker ps"))
    val errorStream = process.errorStream
    val outputStream = process.inputStream

    val exitCode = process.waitFor()

    fun isSuccess(): Boolean {
        // Check exit code (0 indicates successful execution)
        return exitCode == 0
    }

    fun isDockerRunning(): Boolean {
        // Check for errors in the error stream (empty if successful)
        if (errorStream.read() != -1) {
            return false
        }

        // Check for any output in the output stream (indicates at least one container)
        return outputStream.read() != -1
    }

    if (isSuccess()) {
        if (isDockerRunning()) {

            println("Docker networks list:")
            println(runBashCommand(arrayOf("/bin/bash", "-c", "docker network ls")))
            println("Enter your desired network name to scan for possible vulnerabilities:")
            val networkName = readln()
            // check if the networkName is valid and is in the list of networks
            if (!runBashCommand(arrayOf("/bin/bash", "-c", "docker network ls")).contains(networkName)) {
                println("Invalid network name. Please enter a valid network name.")
                throw Exception("Invalid network name.")
            }

            // Start Docker containers
            runBashCommand(
                arrayOf(
                    "/bin/bash",
                    "-c",
                    "docker start \$(docker ps -aq --filter network=$networkName)"
                )
            )

            val serviceDetailsList = getServiceDetailsFromNetwork(networkName)
            writeToFile(
                "/Users/parsa/IdeaProjects/Functional-and-Security-Testing-Techniques/Security Part/VulnerabilityScanner/src/main/resources/network_services.json",
                kotlinObjectToJson(serviceDetailsList)
            )
            if (serviceDetailsList.isEmpty()) {
                println("No services found in the network.")
                return
            }
            serviceDetailsList.forEach { serviceDetails ->
                val vulnerabilities = fetchAllVulnerabilities(
                    serviceDetails.serviceVendor,
                    serviceDetails.serviceType!!,
                    serviceDetails.serviceVersion
                )
                println("${serviceDetails.serviceType} (version: ${serviceDetails.serviceVersion}) vulnerabilities (CVE IDs List):")
                vulnerabilities.forEach { vulnerability ->
                    println(vulnerability.cve.id)
                }
                println("---------------------------------------------------")
            }

            // Stop Docker containers
            runBashCommand(
                arrayOf(
                    "/bin/bash",
                    "-c",
                    "docker stop \$(docker ps -aq --filter network=$networkName)"
                )
            )
        }
    } else {
        println("Docker daemon is not running. Please start Docker daemon and try again.")
    }
}