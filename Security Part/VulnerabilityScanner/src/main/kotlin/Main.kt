import com.google.gson.Gson
import okhttp3.OkHttpClient
import okhttp3.Request
import java.io.File
import java.io.IOException
import java.nio.file.Paths
import java.util.concurrent.TimeUnit
import kotlin.system.exitProcess

const val FILE_FORMAT_INCORRECT_CODE = 100
const val FILE_NAME_INCORRECT_CODE = 101
fun main() {
    // TODO: readFileDirectlyAsText function should be called with the correct file path
    readFileDirectlyAsText(filePath = "${Paths.get("").toAbsolutePath()}/src/main/kotlin/${getFileNameFromUser()}")
    val vulnerabilities = parseVulnerabilities(
        fetchVulnerabilityDataFromNVD(
            serviceVendor = "microsoft",
            serviceType = "windows_10",
            serviceVersion = "1607"
        )
    )
}

fun readFileDirectlyAsText(filePath: String): String {
    var output = ""
    if (filePath.endsWith("json", true) || filePath.endsWith("xml", true) || filePath.endsWith("yaml", true)) {
        if (File(filePath).exists()) {
            output = File(filePath).readText(Charsets.UTF_8)
        } else {
            println("'File name' is incorrect! Try again..")
            exitProcess(FILE_NAME_INCORRECT_CODE)
        }
    } else {
        println("'File format' is incorrect! Try again..")
        exitProcess(FILE_FORMAT_INCORRECT_CODE)
    }
    return output
}

fun getFileNameFromUser(): String? {
    println("Enter the input file name (valid file formats: JSON, XML, and YAML):")
    return readlnOrNull()
}

fun fetchVulnerabilityDataFromNVD(serviceVendor: String, serviceType: String, serviceVersion: String): String {
    val baseURL = "https://services.nvd.nist.gov/rest/json/cves/2.0"
    val query = "?cpeName=cpe:2.3:o:${serviceVendor}:${serviceType}:${serviceVersion}"
    val httpRequestExecutor = HttpRequestExecutor()
    return httpRequestExecutor.run("${baseURL}${query}")
}

fun parseVulnerabilities(jsonString: String): List<Vulnerability>? {
    val gsonResult = Gson().fromJson(jsonString, Vulnerabilities::class.java)
    val vulnerabilities = gsonResult.vulnerabilities
    return vulnerabilities.ifEmpty {
        null
    }
}

class HttpRequestExecutor {
    @Throws(IOException::class)
    fun run(url: String): String {
        val client = OkHttpClient.Builder().readTimeout(1, TimeUnit.MINUTES).build()
        val request = Request.Builder().url(url).build()
        client.newCall(request).execute().use { response ->
            return response.body?.string() ?: ""
        }
    }
}