import com.google.gson.Gson
import com.google.gson.reflect.TypeToken

fun main() {

    val usageType = askUserForInputType()
    if (usageType == UsageType.MANUAL) {
        //val inputFileAddress = getInputFileAddressFromUser().ifEmpty {
        //    "/Users/parsa/IdeaProjects/Functional-and-Security-Testing-Techniques/Security Part/VulnerabilityScanner/src/main/resources/input.json"
        //}
        val inputFile =
            readFromFile("/Users/parsa/IdeaProjects/Functional-and-Security-Testing-Techniques/Security Part/VulnerabilityScanner/src/main/resources/input.json")
        if (inputFile != null) {
            val listType = object : TypeToken<List<Service>>() {}.type
            val services: List<Service> = Gson().fromJson(inputFile, listType)
            val newServices: MutableList<Service> = mutableListOf()
            services.forEach { service ->
                val ipAddress = service.ipAddress
                val url = service.url
                val ports = service.ports
                val type = service.type
                if (type == ServiceType.WORDPRESS.toString().lowercase()) {
                    val version = getWordPressVersion(url = url)["version"]
                    service.version = version
                    newServices.add(service)
                    if (version != null) {
                        val vulnerabilities =
                            fetchAllVulnerabilities(serviceVendor = type, serviceType = type, serviceVersion = version)
                        println("URL: $url -> ${vulnerabilities.size} vulnerabilities")
                        printVulnerabilities(
                            serviceType = type,
                            serviceVersion = version,
                            vulnerabilities = vulnerabilities
                        )
                    }
                }
            }
            writeToFile(
                "/Users/parsa/IdeaProjects/Functional-and-Security-Testing-Techniques/Security Part/VulnerabilityScanner/src/main/resources/input.json",
                kotlinObjectToJson(newServices)
            )
        }

    } else if (usageType == UsageType.DOCKER) {
        if (isProcessExecutionSuccessful()) {
            if (checkDockerDaemonStatus()) {
                showDockerNetworks()
                val networkName = getUserInput("Enter your desired network name to scan for possible vulnerabilities:")
                if (checkIfDockerNetworkNameIsCorrect(networkName)) {
                    startDockerContainers(networkName)
                    val serviceDetailsList = getServiceDetailsFromNetwork(networkName)
                    if (serviceDetailsList.isEmpty()) {
                        println("There is no service running in the network.")
                        writeToFile(
                            "/Users/parsa/IdeaProjects/Functional-and-Security-Testing-Techniques/Security Part/VulnerabilityScanner/src/main/resources/network_services.json",
                            Gson().toJson(mapOf("message" to "There is no running service in the network."))
                        )
                        return
                    } else {
                        writeToFile(
                            "/Users/parsa/IdeaProjects/Functional-and-Security-Testing-Techniques/Security Part/VulnerabilityScanner/src/main/resources/network_services.json",
                            kotlinObjectToJson(serviceDetailsList)
                        )
                    }
                    serviceDetailsList.forEach { serviceDetails ->
                        val vulnerabilities = fetchAllVulnerabilities(
                            serviceDetails.serviceVendor,
                            serviceDetails.serviceType!!,
                            serviceDetails.serviceVersion
                        )
                        printVulnerabilities(
                            serviceType = serviceDetails.serviceType,
                            serviceVersion = serviceDetails.serviceVersion,
                            vulnerabilities = vulnerabilities
                        )
                        println("---------------------------------------------------")
                    }
                    stopDockerContainers(networkName)
                } else {
                    println("Network name is incorrect. Rerun the program and enter a valid network name.")
                    return
                }
            }
        } else {
            println("Docker daemon is not running. Please start Docker daemon and try again.")
        }
    } else {
        println("Usage Type is not correct, Try again.")
        return
    }

}

