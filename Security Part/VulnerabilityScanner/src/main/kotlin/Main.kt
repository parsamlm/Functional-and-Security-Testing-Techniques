import com.google.gson.Gson
import com.google.gson.reflect.TypeToken
import java.io.File

fun main() {
    if (checkIfNetworkIsAvailable()) {
        val usageType = askUserForInputType()
        when (usageType) {
            UsageType.MANUAL -> {
                val userInputFileAddress =
                    getDirectory("resources") + getUserInput("Enter the path of the .json as an input file (e.g., input.json):")
                val file = File(userInputFileAddress)

                if (!file.exists() || !file.isFile) {
                    println("The file does not exist or is not a file. Please try again.")
                    return
                }

                val inputFile = readFromFile(userInputFileAddress) ?: return
                val services: List<Service> = Gson().fromJson(inputFile, object : TypeToken<List<Service>>() {}.type)
                val newServices = services.onEach { service ->
                    when (service.type?.lowercase()) {

                        ServiceType.WORDPRESS.toString().lowercase() -> {
                            service.version = getWordPressVersion(url = service.url)["version"]
                            service.version?.let { version ->
                                service.type.let { type ->
                                    val vulnerabilities = fetchAllVulnerabilities(
                                        vendor = type,
                                        type = type,
                                        version = version
                                    )
                                    service.vulnerabilities = vulnerabilities
                                }
                            }
                        }

                        ServiceType.MYSQL.toString().lowercase() -> {
                            service.version = getMySQLVersion()
                            service.version?.let { version ->
                                service.type.let { type ->
                                    val vulnerabilities = fetchAllVulnerabilities(
                                        vendor = type,
                                        type = type,
                                        version = version
                                    )
                                    service.vulnerabilities = vulnerabilities
                                }
                            }
                        }

                        ServiceType.APACHE.toString().lowercase() -> {
                            service.version = getApacheVersion()
                            service.version?.let { version ->
                                service.type.let { type ->
                                    val vulnerabilities = fetchAllVulnerabilities(
                                        vendor = type,
                                        type = type,
                                        version = version
                                    )
                                    service.vulnerabilities = vulnerabilities
                                }
                            }
                        }

                        else -> {
                            println("Service type is not supported. Supported service types are: WORDPRESS, MYSQL, APACHE.")
                        }
                    }
                }
                writeToFile(userInputFileAddress, kotlinObjectToJson(newServices))
                createOutput(manualServices = newServices, dockerServices = null)
            }

            UsageType.DOCKER -> {
                val networkServices = getDirectory("resources") + "network_services.json"
                if (!isProcessExecutionSuccessful() || !checkDockerDaemonStatus()) {
                    println("Docker daemon is not running. Please start Docker daemon and try again.")
                    return
                }

                showDockerNetworks()
                val networkName = getUserInput("Enter your desired network name to scan for possible vulnerabilities:")
                if (!checkIfDockerNetworkNameIsCorrect(networkName)) {
                    println("Network name is incorrect. Rerun the program and enter a valid network name.")
                    return
                }

                startDockerContainers(networkName)
                val services = getServiceDetailsFromNetwork(networkName)
                if (services.isEmpty()) {
                    println("There is no service running in the network.")
                    writeToFile(
                        networkServices,
                        Gson().toJson(mapOf("message" to "There is no running service in the network."))
                    )
                    return
                }

                services.forEach { service ->
                    val vulnerabilities = fetchAllVulnerabilities(
                        findOnlyVulnerable = false,
                        vendor = service.vendor,
                        type = service.type!!,
                        version = service.version
                    )
                    service.vulnerabilities = vulnerabilities

                    writeToFile(networkServices, kotlinObjectToJson(services))
                    createOutput(manualServices = null, dockerServices = services, dockerNetworkName = networkName)
                }
                stopDockerContainers(networkName)
            }

            else -> {
                println("Usage Type is not correct, Try again.")
                return
            }
        }
    } else {
        println("This script needs network connection. Please check your network connection and try again.")
    }


}