import com.google.gson.Gson
import com.google.gson.reflect.TypeToken
import helper.*
import model.Service
import service.*
import java.io.File
import com.parsamlm.VF.fetchAllVulnerabilities

var apiKey: String? = null
fun main() {
    apiKey = retrieveAPIKeyFromJsonFile()
    if (!isInternetConnectionAvailable()) {
        println("This script needs network connection. Please check your network connection and try again.")
        return
    }

    when (askUserForInputType()) {
        InputSourceType.MANUAL -> handleManualUsageType()
        InputSourceType.DOCKER -> handleDockerUsageType()
        else -> println("Usage Type is not correct, Try again.")
    }
}

fun handleManualUsageType() {
    val userInputFileAddress =
        getDirectory("resources") + promptUserAndRetrieveInput("Enter the input file name (e.g., input.json):")
    val file = File(userInputFileAddress)

    if (!file.exists() || !file.isFile) {
        println("The file does not exist or is not a file. Please try again.")
        return
    }

    val inputFile = readTextFromFile(userInputFileAddress) ?: return
    val services: List<Service> = Gson().fromJson(inputFile, object : TypeToken<List<Service>>() {}.type)
    services.onEach { handleServiceType(it) }
    writeTextToFile(userInputFileAddress, serializeObjectToJson(services))
    generateVulnerabilityReportAsPDF(services = services)
    println("Vulnerability report (output.pdf) has been generated successfully.")
}

fun handleDockerUsageType() {
    val networkServices = getDirectory("resources") + "network_services.json"
    if (!isDockerProcessExitCodeSuccessful() || !isDockerDaemonRunning()) {
        println("Docker daemon is not running. Please start Docker daemon and try again.")
        return
    }

    displayDockerNetworkList()
    val networkName =
        promptUserAndRetrieveInput("Enter your desired network name to scan for possible vulnerabilities:")
    if (!isNetworkNameInDockerNetworks(networkName)) {
        println("Network name is incorrect. Rerun the program and enter a valid network name.")
        return
    }

    startContainersInSpecifiedNetwork(networkName)
    // sleep for 5 seconds to allow services to start
    Thread.sleep(5000)
    try {
        val services = getServicesFromDockerNetwork(networkName)
        services.forEach { service ->
            service.vulnerabilities = fetchAllVulnerabilities(
                apiKey = apiKey,
                findOnlyVulnerable = false,
                vendor = service.vendor!!,
                type = service.type!!,
                version = service.version!!
            )
            writeTextToFile(networkServices, serializeObjectToJson(services))
            generateVulnerabilityReportAsPDF(services = services, dockerNetworkName = networkName)
        }
    } catch (e: Exception) {
        println("You have tried to send many requests to the NVD website. Please try again later or use an API key.")
    }
    stopContainersInSpecifiedNetwork(networkName)
    println("Vulnerability report (output.pdf) has been generated successfully.")
}

fun handleServiceType(service: Service) {
    when (service.type?.lowercase()) {
        ServiceType.WORDPRESS.toString().lowercase() -> updateServiceVersionAndFetchVulnerabilities(
            service,
            fetchWordPressVersionFromMetaTag(url = service.url) ?: "Unknown"
        )

        ServiceType.MYSQL.toString().lowercase() -> updateServiceVersionAndFetchVulnerabilities(
            service,
            getMySQLVersion()
        )

        ServiceType.APACHE.toString().lowercase() -> updateServiceVersionAndFetchVulnerabilities(
            service,
            fetchApacheVersionFromBashCommand()
        )

        else -> println("model.Service type is not supported. Supported service types are: WORDPRESS, MYSQL, APACHE.")
    }
}

/**
 * Updates the service with the provided version and retrieves all vulnerabilities related to the service.
 *
 * This function updates the version of the provided service and retrieves all vulnerabilities related to the service from the NVD (National Vulnerability Database).
 * The function uses the retrieveAllVulnerabilitiesFromNVD function to retrieve the vulnerabilities.
 * The vendor, type, and version parameters for the retrieveAllVulnerabilitiesFromNVD function are taken from the service object and the version parameter.
 * The function updates the vulnerabilities property of the service object with the retrieved vulnerabilities.
 *
 * @param service The service to be updated.
 * @param version The version to be set for the service.
 */
fun updateServiceVersionAndFetchVulnerabilities(service: Service, version: String) {
    service.version = version
    if (version != "Unknown") {
        try {
            service.vulnerabilities = fetchAllVulnerabilities(
                apiKey = apiKey,
                findOnlyVulnerable = false,
                vendor = service.type!!,
                type = service.type,
                version = version
            )
        } catch (e: Exception) {
            println("You have tried to send many requests to the NVD website. Please try again later or use an API key.")
        }
    }
}
