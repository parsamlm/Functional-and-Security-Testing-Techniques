import com.google.gson.Gson
import java.io.File
import java.io.InputStream

inline fun <reified T> jsonToKotlinObject(jsonString: String): T {
    return Gson().fromJson(jsonString, T::class.java)
}

inline fun <reified T> kotlinObjectToJson(obj: T): String {
    return Gson().toJson(obj)
}

val serviceVendorToServiceType = mapOf(
    "httpd" to "apache",
    "mysql" to "mysql",
    "wordpress" to "wordpress",
    "zookeeper" to "zookeeper",
    "joomla" to "joomla",
)

fun readFromFile(filePath: String): String? {
    return File(filePath).takeIf { it.exists() }?.readText()
}

fun writeToFile(fileName: String, data: String) {
    File(fileName).writeText(data)
}

fun runBashCommand(command: Array<String>): String {
    return Runtime.getRuntime()
        .exec(
            command
        )
        .inputStream
        .bufferedReader()
        .readText()
        .trim()
}

fun isHostReachable(host: String): Boolean {
    return try {
        val process = Runtime.getRuntime().exec("ping -c 1 $host")
        val exitCode = process.waitFor()
        exitCode == 0
    } catch (e: Exception) {
        false
    }
}

fun showDockerNetworks() {
    println("Docker networks list:")
    println(runBashCommand(arrayOf("/bin/bash", "-c", "docker network ls")))
}

fun getUserInput(message: String): String {
    println(message)
    return readln()
}

fun checkIfDockerNetworkNameIsCorrect(networkName: String): Boolean {
    return runBashCommand(arrayOf("/bin/bash", "-c", "docker network ls")).contains(networkName)
}

fun startDockerContainers(networkName: String) {
    runBashCommand(
        arrayOf(
            "/bin/bash",
            "-c",
            "docker start \$(docker ps -aq --filter network=$networkName)"
        )
    )
}

fun stopDockerContainers(networkName: String) {
    runBashCommand(
        arrayOf(
            "/bin/bash",
            "-c",
            "docker stop \$(docker ps -aq --filter network=$networkName)"
        )
    )
}

val process: Process = Runtime.getRuntime().exec(arrayOf("bash", "-c", "docker ps"))
val errorStream: InputStream = process.errorStream
val outputStream: InputStream = process.inputStream

val exitCode = process.waitFor()

fun isProcessExecutionSuccessful(): Boolean {
    // Check exit code (0 indicates successful execution)
    return exitCode == 0
}

fun checkDockerDaemonStatus(): Boolean {
    // Check for errors in the error stream (empty if successful)
    if (errorStream.read() != -1) {
        return false
    }
    // Check for any output in the output stream (indicates at least one container)
    return outputStream.read() != -1
}


enum class UsageType {
    MANUAL,
    DOCKER,
    NONE
}