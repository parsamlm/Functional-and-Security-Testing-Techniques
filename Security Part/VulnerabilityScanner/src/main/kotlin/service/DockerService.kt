package service

import com.google.gson.Gson
import com.google.gson.reflect.TypeToken
import helper.executeBashCommandAndReturnOutput
import model.Container
import model.Service
import java.io.InputStream

fun getServicesFromDockerNetwork(networkName: String): List<Service> {
    return getContainerNamesInDockerNetwork(networkName)
        .filter { it.isNotEmpty() }
        .flatMap { convertJsonToContainerList(inspectDockerContainer(it)).toList() }
        .map { container ->
            val (serviceVendor, serviceVersion) = container.config.image.split(":")
            Service(
                ipAddress = container.networkSettings.networks[networkName]?.ipAddress ?: "",
                ports = container.networkSettings.ports.keys,
                vendor = serviceVendor,
                type = vendorToServiceTypeMapping[serviceVendor],
                version = serviceVersion,
                vulnerabilities = null,
                url = null
            )
        }
}

private fun inspectDockerContainer(containerName: String): String =
    executeBashCommandAndReturnOutput(arrayOf("/bin/bash", "-c", "docker inspect $containerName"))

private fun getContainerNamesInDockerNetwork(networkName: String): List<String> = executeBashCommandAndReturnOutput(
    arrayOf(
        "/bin/bash",
        "-c",
        "docker network inspect --format '{{range .Containers}}{{.Name}} {{end}}' $networkName"
    )
).split(" ")

/**
 * Data class representing a Description.
 *
 * This class holds the language and value of a Description.
 * The language represents the language in which the description is written.
 * The value is the actual description text.
 *
 * @property lang The language in which the description is written.
 * @property value The actual description text.
 */
private fun convertJsonToContainerList(jsonString: String): List<Container> {
    val listType = object : TypeToken<List<Container>>() {}.type
    return Gson().fromJson(jsonString, listType)
}

val dockerProcess: Process = Runtime.getRuntime().exec(arrayOf("bash", "-c", "docker ps"))
val dockerProcessErrorStream: InputStream = dockerProcess.errorStream
val dockerProcessOutputStream: InputStream = dockerProcess.inputStream
val dockerProcessExitCode = dockerProcess.waitFor()
/**
 * Checks if the Docker process exit code is successful.
 *
 * This function checks if the exit code of the Docker process is 0, which indicates a successful execution.
 * If the exit code is 0, the function returns true. Otherwise, it returns false.
 *
 * @return A boolean value indicating whether the Docker process exit code is successful.
 */
fun isDockerProcessExitCodeSuccessful(): Boolean = dockerProcessExitCode == 0

fun isDockerDaemonRunning(): Boolean = dockerProcessErrorStream.read() == -1 && dockerProcessOutputStream.read() != -1

fun isNetworkNameInDockerNetworks(networkName: String): Boolean =
    executeBashCommandAndReturnOutput(arrayOf("/bin/bash", "-c", "docker network ls")).contains(networkName)

fun startContainersInSpecifiedNetwork(networkName: String) =
    executeBashCommandAndReturnOutput(
        arrayOf(
            "/bin/bash",
            "-c",
            "docker start \$(docker ps -aq --filter network=$networkName)"
        )
    )

fun stopContainersInSpecifiedNetwork(networkName: String) =
    executeBashCommandAndReturnOutput(
        arrayOf(
            "/bin/bash",
            "-c",
            "docker stop \$(docker ps -aq --filter network=$networkName)"
        )
    )

fun displayDockerNetworkList() =
    println("Docker networks list:\n${
        executeBashCommandAndReturnOutput(
            arrayOf(
                "/bin/bash",
                "-c",
                "docker network ls"
            )
        )
    }")

val vendorToServiceTypeMapping = mapOf(
    "httpd" to "apache",
    "mysql" to "mysql",
    "wordpress" to "wordpress",
    "zookeeper" to "zookeeper",
    "joomla" to "joomla",
)