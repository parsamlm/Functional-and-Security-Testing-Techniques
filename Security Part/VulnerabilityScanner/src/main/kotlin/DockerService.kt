import java.io.InputStream

fun getServiceDetailsFromNetwork(networkName: String): Set<ServiceDetails> {
    val serviceDetailsList = mutableSetOf<ServiceDetails>()
    val containerNames = findDockerContainersInNetwork(networkName)

    for (containerName in containerNames) {
        if (containerName.isNotEmpty()) {
            val containers = parseContainersFromJson(getContainerDetails(containerName))
            for (container in containers) {
                val (serviceVendor, serviceVersion) = container.config.image.split(":")
                val serviceDetails = ServiceDetails(
                    ipAddress = container.networkSettings.networks[networkName]?.ipAddress ?: "",
                    ports = container.networkSettings.ports.keys,
                    vendor = serviceVendor,
                    type = serviceVendorToServiceType[serviceVendor],
                    version = serviceVersion,
                    vulnerabilities = null
                )
                serviceDetailsList.add(serviceDetails)
            }
        }
    }

    return serviceDetailsList
}

fun getContainerDetails(containerName: String): String {
    return runBashCommand(arrayOf("/bin/bash", "-c", "docker inspect $containerName"))
}

fun findDockerContainersInNetwork(networkName: String): List<String> {
    return runBashCommand(
        arrayOf(
            "/bin/bash",
            "-c",
            "docker network inspect --format '{{range .Containers}}{{.Name}} {{end}}' $networkName"
        )
    ).split(" ")
}

fun parseContainersFromJson(jsonString: String): Array<Container> {
    return jsonToObject(jsonString)
}

val process: Process = Runtime.getRuntime().exec(arrayOf("bash", "-c", "docker ps"))
val errorStream: InputStream = process.errorStream
val outputStream: InputStream = process.inputStream
val exitCode = process.waitFor()
fun isProcessExecutionSuccessful(): Boolean {
    // Check exit code (0 indicates successful execution)
    return exitCode == 0
}

fun checkDockerDaemonStatus(): Boolean {
    // Check for errors in the error stream (empty if successful)
    if (errorStream.read() != -1) {
        return false
    }
    // Check for any output in the output stream (indicates at least one container)
    return outputStream.read() != -1
}

fun checkIfDockerNetworkNameIsCorrect(networkName: String): Boolean {
    return runBashCommand(arrayOf("/bin/bash", "-c", "docker network ls")).contains(networkName)
}

fun startDockerContainers(networkName: String) {
    runBashCommand(
        arrayOf(
            "/bin/bash",
            "-c",
            "docker start \$(docker ps -aq --filter network=$networkName)"
        )
    )
}

fun stopDockerContainers(networkName: String) {
    runBashCommand(
        arrayOf(
            "/bin/bash",
            "-c",
            "docker stop \$(docker ps -aq --filter network=$networkName)"
        )
    )
}

fun showDockerNetworks() {
    println("Docker networks list:")
    println(runBashCommand(arrayOf("/bin/bash", "-c", "docker network ls")))
}

val serviceVendorToServiceType = mapOf(
    "httpd" to "apache",
    "mysql" to "mysql",
    "wordpress" to "wordpress",
    "zookeeper" to "zookeeper",
    "joomla" to "joomla",
)