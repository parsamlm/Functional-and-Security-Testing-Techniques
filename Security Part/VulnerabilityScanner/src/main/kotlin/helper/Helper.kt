package helper

import com.google.gson.Gson
import com.itextpdf.kernel.colors.ColorConstants
import com.itextpdf.kernel.pdf.PdfWriter
import com.itextpdf.layout.Document
import com.itextpdf.layout.element.Cell
import com.itextpdf.layout.element.Paragraph
import com.itextpdf.layout.element.Table
import com.itextpdf.layout.properties.UnitValue
import model.Service
import okhttp3.OkHttpClient
import okhttp3.Request
import java.io.File
import java.io.IOException
import java.util.concurrent.TimeUnit

/**
 * Serializes an object to a JSON string.
 *
 * @param obj The object to be serialized. The object's class should be known at compile time.
 * @return The JSON string representation of the object.
 */
inline fun <reified T> serializeObjectToJson(obj: T): String = Gson().toJson(obj)

/**
 * Reads the content of a file and returns it as a String.
 *
 * @param filePath The path of the file to be read. The path should be absolute.
 * @return The content of the file as a String. If the file does not exist, returns null.
 */
fun readTextFromFile(filePath: String): String? = File(filePath).takeIf { it.exists() }?.readText()

/**
 * Writes the provided data to a file with the given name.
 *
 * @param fileName The name of the file where the data will be written. If the file does not exist, it will be created.
 * @param data The data to be written to the file.
 */
fun writeTextToFile(fileName: String, data: String) = File(fileName).writeText(data)


/**
 * Executes a bash command and returns the output.
 *
 * This function uses the Runtime class from the java.lang package to execute a bash command.
 * The command is provided as an array of strings, where each string is a separate part of the command.
 * The function reads the output of the command from the input stream of the Process object returned by the exec method.
 * The output is read as a string and any leading and trailing whitespace is removed.
 * The function returns the output of the command as a string.
 *
 * @param command The bash command to be executed. The command is provided as an array of strings.
 * @return The output of the command as a string.
 */
fun executeBashCommandAndReturnOutput(command: Array<String>): String =
    Runtime.getRuntime().exec(command).inputStream.bufferedReader().readText().trim()

/**
 * Prompts the user with a message and retrieves the user's input.
 *
 * @param message The message to display to the user.
 * @return The user's input as a String.
 */
fun promptUserAndRetrieveInput(message: String): String {
    println(message); return readln()
}

/**
 * A class that executes HTTP requests.
 */
class HttpRequestExecutor {
    /**
     * Executes an HTTP request to the specified URL and returns the response body as a String.
     *
     * @param url The URL to which the request will be sent.
     * @param apiKey An optional API key to be included in the request header. If null, no API key will be included.
     * @return The response body as a String. If the response body is null, returns an empty String.
     * @throws IOException if an I/O error occurs during the execution of the request.
     */
    @Throws(IOException::class)
    fun run(url: String, apiKey: String? = null): String {
        val client = OkHttpClient.Builder().readTimeout(1, TimeUnit.MINUTES).build()
        val request: Request = Request.Builder().url(url).apply { apiKey?.let { addHeader("apiKey", it) } }.build()
        return client.newCall(request).execute().use { it.body?.string() ?: "" }
    }
}

/**
 * Enum representing the source of input for the script.
 *
 * @property MANUAL Indicates that the input will be provided manually by the user.
 * @property DOCKER Indicates that the input will be provided through Docker.
 * @property NONE Indicates that no input source has been selected.
 */
enum class InputSourceType { MANUAL, DOCKER, NONE }

/**
 * Asks the user to select the input source type for the script.
 *
 * @return The selected InputSourceType based on the user's input.
 */
fun askUserForInputType(): InputSourceType {
    val userInput =
        promptUserAndRetrieveInput("How do you want to use the script?\n1. Manual\n2. Docker\nEnter the corresponding number:")
    return when {
        userInput.lowercase().contains("manual") || userInput == "1" -> InputSourceType.MANUAL
        userInput.lowercase().contains("docker") || userInput == "2" -> InputSourceType.DOCKER
        else -> InputSourceType.NONE
    }
}

/**
 * Returns the absolute path to the specified directory in the main source directory of the project.
 *
 * @param directoryName The name of the directory. If no name is provided, the function returns the path to the main source directory.
 * @return The absolute path to the specified directory in the main source directory of the project.
 */
fun getDirectory(directoryName: String = ""): String =
    File("").absoluteFile.absolutePath + "/src/main/${directoryName.lowercase()}/"

/**
 * Checks if an internet connection is available.
 *
 * @return A Boolean value indicating whether an internet connection is available or not.
 * @throws IOException if an I/O error occurs during the execution of the command.
 */
fun isInternetConnectionAvailable(): Boolean = try {
    executeBashCommandAndReturnOutput(arrayOf("ping", "-c", "1", "google.com")).isNotEmpty()
} catch (e: IOException) {
    false
}

/**
 * Generates a PDF report of vulnerabilities for the provided services.
 *
 * @param services A list of Service objects for which the vulnerability report will be generated. If null or empty, no report will be generated.
 * @param dockerNetworkName The name of the Docker network. If provided, it will be included at the beginning of the document. If not provided, no Docker network name will be included.
 */
fun generateVulnerabilityReportAsPDF(services: List<Service>?, dockerNetworkName: String = "") {
    val writer = PdfWriter(getDirectory("resources") + "output.pdf")
    val doc = Document(com.itextpdf.kernel.pdf.PdfDocument(writer))
    if (dockerNetworkName.isNotEmpty()) doc.add(
        Paragraph("Docker Network: $dockerNetworkName\n").setBold().setFontSize(15f)
    )
    services?.forEach { service ->
        doc.add(generateServiceInformationParagraph(service))
        doc.add(generateVulnerabilityDetailsTable(service))
        doc.add(Paragraph("\n"))
    }
    doc.add(
        Paragraph("Developed by Parsamlm").setItalic().setBold().setFontSize(10f)
            .setAction(com.itextpdf.kernel.pdf.action.PdfAction.createURI("https://github.com/parsamlm")).setUnderline()
            .setTextAlignment(com.itextpdf.layout.properties.TextAlignment.CENTER)
    )
    doc.close()
}

private fun generateServiceInformationParagraph(service: Service): Paragraph {
    val serviceInfo = Paragraph()
    service.url?.let { url ->
        serviceInfo.add(" ")
            .add(Paragraph(url).setBold().setAction(com.itextpdf.kernel.pdf.action.PdfAction.createURI(url)))
    }
    serviceInfo.add(" - ${service.type} (version: ${service.version})")
    return serviceInfo
}

private fun generateVulnerabilityDetailsTable(service: Service): Table {
    val table = Table(UnitValue.createPercentArray(floatArrayOf(1f, 1f, 1f))).useAllAvailableWidth()
    table.addHeaderCell(Cell().add(Paragraph("Vulnerability").setBold()))
    table.addHeaderCell(Cell().add(Paragraph("Description").setBold()))
    table.addHeaderCell(Cell().add(Paragraph("Severity").setBold()))

    service.vulnerabilities?.sortedBy { it.cve.metrics?.cvssMetricV2?.first()?.baseSeverity }
        ?.forEach { vulnerability ->
            val severity = vulnerability.cve.metrics?.cvssMetricV2?.first()?.baseSeverity ?: " "
            table.addCell(createSeverityBasedCellWithCVELink(vulnerability.cve.id, severity))
            table.addCell(
                createSeverityBasedCellWithBackground(
                    vulnerability.cve.descriptions?.first()?.value,
                    severity
                )
            )
            table.addCell(createSeverityBasedCellWithBackground(severity, severity))
        }
    return table
}

private fun createSeverityBasedCellWithBackground(content: String?, severity: String): Cell {
    val cell = Cell().add(Paragraph(content))
    when (severity) {
        "HIGH" -> cell.setBackgroundColor(ColorConstants.RED, 0.3f)
        "MEDIUM" -> cell.setBackgroundColor(ColorConstants.ORANGE, 0.3f)
        "LOW" -> cell.setBackgroundColor(ColorConstants.GREEN, 0.3f)
        else -> cell.setBackgroundColor(ColorConstants.WHITE)
    }
    return cell
}

private fun createSeverityBasedCellWithCVELink(cveID: String, severity: String): Cell {
    val cell =
        Cell().add(Paragraph(cveID).setAction(com.itextpdf.kernel.pdf.action.PdfAction.createURI("https://nvd.nist.gov/vuln/detail/$cveID")))
            .setFontColor(ColorConstants.BLUE)
    when (severity) {
        "HIGH" -> cell.setBackgroundColor(ColorConstants.RED, 0.3f)
        "MEDIUM" -> cell.setBackgroundColor(ColorConstants.ORANGE, 0.3f)
        "LOW" -> cell.setBackgroundColor(ColorConstants.GREEN, 0.3f)
        else -> cell.setBackgroundColor(ColorConstants.WHITE)
    }
    return cell
}