package helper

import com.google.gson.Gson
import com.itextpdf.kernel.colors.ColorConstants
import com.itextpdf.kernel.pdf.PdfWriter
import com.itextpdf.layout.Document
import com.itextpdf.layout.element.Cell
import com.itextpdf.layout.element.Paragraph
import com.itextpdf.layout.element.Table
import com.itextpdf.layout.properties.UnitValue
import com.mongodb.client.MongoClient
import com.mongodb.client.MongoClients
import model.NVD
import model.Service
import okhttp3.OkHttpClient
import okhttp3.Request
import org.jsoup.Jsoup
import java.io.File
import java.io.IOException
import java.sql.Connection
import java.sql.DriverManager
import java.util.concurrent.TimeUnit

/**
 * Serializes an object to a JSON string.
 *
 * @param obj The object to be serialized. The object's class should be known at compile time.
 * @return The JSON string representation of the object.
 */
inline fun <reified T> serializeObjectToJson(obj: T): String = Gson().toJson(obj)

/**
 * Reads the content of a file and returns it as a String.
 *
 * @param filePath The path of the file to be read. The path should be absolute.
 * @return The content of the file as a String. If the file does not exist, returns null.
 */
fun readTextFromFile(filePath: String): String? = File(filePath).takeIf { it.exists() }?.readText()

/**
 * Writes the provided data to a file with the given name.
 *
 * @param fileName The name of the file where the data will be written. If the file does not exist, it will be created.
 * @param data The data to be written to the file.
 */
fun writeTextToFile(fileName: String, data: String) = File(fileName).writeText(data)


/**
 * Executes a bash command and returns the output.
 *
 * This function uses the Runtime class from the java.lang package to execute a bash command.
 * The command is provided as an array of strings, where each string is a separate part of the command.
 * The function reads the output of the command from the input stream of the Process object returned by the exec method.
 * The output is read as a string and any leading and trailing whitespace is removed.
 * The function returns the output of the command as a string.
 *
 * @param command The bash command to be executed. The command is provided as an array of strings.
 * @return The output of the command as a string.
 */
fun executeBashCommandAndReturnOutput(command: Array<String>): String =
    Runtime.getRuntime().exec(command).inputStream.bufferedReader().readText().trim()

/**
 * Prompts the user with a message and retrieves the user's input.
 *
 * @param message The message to display to the user.
 * @return The user's input as a String.
 */
fun promptUserAndRetrieveInput(message: String): String {
    println(message); return readln()
}

/**
 * A class that executes HTTP requests.
 */
class HttpRequestExecutor {
    /**
     * Executes an HTTP request to the specified URL and returns the response body as a String.
     *
     * @param url The URL to which the request will be sent.
     * @param apiKey An optional API key to be included in the request header. If null, no API key will be included.
     * @return The response body as a String. If the response body is null, returns an empty String.
     * @throws IOException if an I/O error occurs during the execution of the request.
     */
    @Throws(IOException::class)
    fun run(url: String, apiKey: String? = null): String {
        val client = OkHttpClient.Builder().readTimeout(1, TimeUnit.MINUTES).build()
        val request: Request = Request.Builder().url(url).apply { apiKey?.let { addHeader("apiKey", it) } }.build()
        return client.newCall(request).execute().use { it.body?.string() ?: "" }
    }
}

/**
 * Enum representing the source of input for the script.
 *
 * @property MANUAL Indicates that the input will be provided manually by the user.
 * @property DOCKER Indicates that the input will be provided through Docker.
 * @property NONE Indicates that no input source has been selected.
 */
enum class InputSourceType { MANUAL, DOCKER, NONE }

fun askUserForInputType(): InputSourceType {
    val userInput =
        promptUserAndRetrieveInput("How do you want to use the script?\n1. Manual\n2. Docker\nEnter the corresponding number:")
    return when {
        userInput.lowercase().contains("manual") || userInput == "1" -> InputSourceType.MANUAL
        userInput.lowercase().contains("docker") || userInput == "2" -> InputSourceType.DOCKER
        else -> InputSourceType.NONE
    }
}

/**
 * Returns the absolute path to the specified directory in the main source directory of the project.
 *
 * @param directoryName The name of the directory. If no name is provided, the function returns the path to the main source directory.
 * @return The absolute path to the specified directory in the main source directory of the project.
 */
fun getDirectory(directoryName: String = ""): String =
    File("").absoluteFile.absolutePath + "/src/main/${directoryName.lowercase()}/"

fun isInternetConnectionAvailable(): Boolean = try {
    executeBashCommandAndReturnOutput(arrayOf("ping", "-c", "1", "google.com")).isNotEmpty()
} catch (e: IOException) {
    false
}

/**
 * Generates a PDF report of vulnerabilities for the provided services.
 *
 * @param services A list of Service objects for which the vulnerability report will be generated. If null or empty, no report will be generated.
 * @param dockerNetworkName The name of the Docker network. If provided, it will be included at the beginning of the document. If not provided, no Docker network name will be included.
 */
fun generateVulnerabilityReportAsPDF(services: List<Service>?, dockerNetworkName: String = "") {
    val writer = PdfWriter(getDirectory("resources") + "output.pdf")
    val doc = Document(com.itextpdf.kernel.pdf.PdfDocument(writer))
    if (dockerNetworkName.isNotEmpty()) doc.add(
        Paragraph("Docker Network: $dockerNetworkName\n").setBold().setFontSize(15f)
    )
    services?.forEach { service ->
        doc.add(generateServiceInformationParagraph(service))
        if (service.vulnerabilities != null && service.version != "Unknown")
            doc.add(generateVulnerabilityDetailsTable(service))
        else if (service.version != "Unknown")
            doc.add(Paragraph("There is no vulnerability for this service."))
        else
            doc.add(Paragraph("There is no vulnerability for this service as its version is not obvious."))

        doc.add(Paragraph("\n"))
    }
    doc.add(
        Paragraph("Developed by Parsamlm").setItalic().setBold().setFontSize(10f)
            .setAction(com.itextpdf.kernel.pdf.action.PdfAction.createURI("https://github.com/parsamlm")).setUnderline()
            .setTextAlignment(com.itextpdf.layout.properties.TextAlignment.CENTER)
    )
    doc.close()
}

fun retrieveAPIKeyFromJsonFile(): String? {
    val apiKeyFile = getDirectory("resources") + "nvd_api.json"
    val apiKey = readTextFromFile(apiKeyFile)
    return Gson().fromJson(apiKey, NVD::class.java).apiKey
}

private fun generateServiceInformationParagraph(service: Service): Paragraph {
    val serviceInfo = Paragraph()
    service.url?.let { url ->
        serviceInfo.add(" ")
            .add(Paragraph(url).setBold().setAction(com.itextpdf.kernel.pdf.action.PdfAction.createURI(url)))
    }
    serviceInfo.add(" - ${service.type} (version: ${service.version})")
    return serviceInfo
}

private fun generateVulnerabilityDetailsTable(service: Service): Table {
    val table = Table(UnitValue.createPercentArray(floatArrayOf(1f, 1f, 1f))).useAllAvailableWidth()
    table.addHeaderCell(Cell().add(Paragraph("Vulnerability").setBold()))
    table.addHeaderCell(Cell().add(Paragraph("Description").setBold()))
    table.addHeaderCell(Cell().add(Paragraph("Severity").setBold()))

    service.vulnerabilities?.sortedWith(compareBy {
        when (it.cve.metrics?.cvssMetricV2?.first()?.baseSeverity) {
            "HIGH" -> 0
            "MEDIUM" -> 1
            "LOW" -> 2
            else -> 3
        }
    })?.forEach { vulnerability ->
        val severity = vulnerability.cve.metrics?.cvssMetricV2?.first()?.baseSeverity ?: " Unknown"
        table.addCell(createSeverityBasedCellWithCVELink(vulnerability.cve.id, severity))
        table.addCell(
            createSeverityBasedCellWithBackground(
                vulnerability.cve.descriptions?.first()?.value,
                severity
            )
        )
        table.addCell(createSeverityBasedCellWithBackground(severity, severity))
    }
    return table
}

private fun createSeverityBasedCellWithBackground(content: String?, severity: String): Cell {
    val cell = Cell().add(Paragraph(content))
    when (severity) {
        "HIGH" -> cell.setBackgroundColor(ColorConstants.RED, 0.3f)
        "MEDIUM" -> cell.setBackgroundColor(ColorConstants.ORANGE, 0.3f)
        "LOW" -> cell.setBackgroundColor(ColorConstants.YELLOW, 0.3f)
        else -> cell.setBackgroundColor(ColorConstants.WHITE)
    }
    return cell
}

private fun createSeverityBasedCellWithCVELink(cveID: String, severity: String): Cell {
    val cell =
        Cell().add(Paragraph(cveID).setAction(com.itextpdf.kernel.pdf.action.PdfAction.createURI("https://nvd.nist.gov/vuln/detail/$cveID")))
            .setFontColor(ColorConstants.BLUE)
    when (severity) {
        "HIGH" -> cell.setBackgroundColor(ColorConstants.RED, 0.3f)
        "MEDIUM" -> cell.setBackgroundColor(ColorConstants.ORANGE, 0.3f)
        "LOW" -> cell.setBackgroundColor(ColorConstants.YELLOW, 0.3f)
        else -> cell.setBackgroundColor(ColorConstants.WHITE)
    }
    return cell
}

private fun fetchWebsiteContentAsString(url: String): String =
    runCatching { HttpRequestExecutor().run(url) }.getOrDefault("")

fun fetchWordPressVersionFromMetaTag(url: String?): String? {
    val content = Jsoup.parse(fetchWebsiteContentAsString(url ?: return null))
        .select("meta[name=generator]").first()?.attr("content")
    return content?.split(" ")?.get(1)
}

var connection: Connection? = null

/**
 * Establishes a connection to a MySQL database using the provided parameters.
 *
 * This function uses the DriverManager class from the java.sql package to establish a connection to a MySQL database.
 * The connection is stored in a global variable named 'connection'.
 * If a connection is already open, it will be replaced.
 *
 * @param url The URL of the MySQL database. The URL should be in the format "jdbc:mysql://<host>:<port>/", where <host> is the IP address or hostname of the MySQL server and <port> is the port number on which the MySQL server is listening.
 * @param username The username to use for authentication with the MySQL server.
 * @param password The password to use for authentication with the MySQL server.
 */
private fun establishMySQLConnection(
    url: String,
    username: String,
    password: String
) {
    connection = DriverManager.getConnection(url, username, password)
}

/**
 * Closes the MySQL database connection.
 *
 * This function closes the MySQL database connection that was previously established.
 * The connection is a global variable named 'connection'.
 * If the connection is null, this function does nothing.
 */
private fun closeMySQLConnection() = connection?.close()

fun getMySQLVersion(
    hostIP: String = "localhost",
    hostPort: String = "3306",
    username: String = "root",
    password: String = ""
): String {
    establishMySQLConnection(url = "jdbc:mysql://$hostIP:$hostPort/", username = username, password = password)
    val version = connection?.createStatement()?.executeQuery("SELECT VERSION()")?.run {
        next()
        getString(1)
    } ?: ""
    closeMySQLConnection()
    return version.split("-")[0]
}

fun fetchApacheVersionFromBashCommand(): String {
    val output = executeBashCommandAndReturnOutput(arrayOf("httpd", "-v"))
    val parts = output.split("\n").firstOrNull()?.split(":")
    val versionDetails = parts?.getOrNull(1)?.split("/")?.getOrNull(1)?.split(" ")
    return versionDetails?.firstOrNull() ?: "Unknown"
}

enum class ServiceType {
    WORDPRESS,
    APACHE,
    MYSQL,
    MONGODB
}

fun fetchMongoDBVersion(
    hostIP: String = "localhost",
    hostPort: String = "27017",
    username: String = "admin",
    password: String = "admin"
): String {
    var version = "Unknown"
    try {
        // Establish a connection
        val mongoClient = MongoClients.create("mongodb://$username:$password@$hostIP:$hostPort/?authMechanism=SCRAM-SHA-1")
        val database = mongoClient.getDatabase("admin")

        // Execute a command to retrieve the version
        val commandResult = database.runCommand(org.bson.Document("buildInfo", 1))

        // Get the version from the command result
        version = commandResult.getString("version")
    } catch (e: Exception) {
        e.printStackTrace()
    }
    return version
}