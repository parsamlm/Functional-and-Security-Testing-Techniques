package helper

import com.google.gson.Gson
import com.itextpdf.kernel.colors.ColorConstants
import com.itextpdf.kernel.pdf.PdfWriter
import com.itextpdf.layout.Document
import com.itextpdf.layout.element.Cell
import com.itextpdf.layout.element.Paragraph
import com.itextpdf.layout.element.Table
import com.itextpdf.layout.properties.UnitValue
import model.Service
import okhttp3.OkHttpClient
import okhttp3.Request
import java.io.File
import java.io.IOException
import java.util.concurrent.TimeUnit

inline fun <reified T> deserializeJsonToType(jsonString: String): T = Gson().fromJson(jsonString, T::class.java)
inline fun <reified T> serializeObjectToJson(obj: T): String = Gson().toJson(obj)
fun readTextFromFile(filePath: String): String? = File(filePath).takeIf { it.exists() }?.readText()
fun writeTextToFile(fileName: String, data: String) = File(fileName).writeText(data)
fun executeBashCommandAndReturnOutput(command: Array<String>): String =
    Runtime.getRuntime().exec(command).inputStream.bufferedReader().readText().trim()

fun promptUserAndRetrieveInput(message: String): String {
    println(message); return readln()
}

class HttpRequestExecutor {
    @Throws(IOException::class)
    fun run(url: String, apiKey: String? = null): String {
        val client = OkHttpClient.Builder().readTimeout(1, TimeUnit.MINUTES).build()
        val request: Request = Request.Builder().url(url).apply { apiKey?.let { addHeader("apiKey", it) } }.build()
        return client.newCall(request).execute().use { it.body?.string() ?: "" }
    }
}

enum class InputSourceType { MANUAL, DOCKER, NONE }

fun askUserForInputType(): InputSourceType {
    val userInput =
        promptUserAndRetrieveInput("How do you want to use the script?\n1. Manual\n2. Docker\nEnter the corresponding number:")
    return when {
        userInput.lowercase().contains("manual") || userInput == "1" -> InputSourceType.MANUAL
        userInput.lowercase().contains("docker") || userInput == "2" -> InputSourceType.DOCKER
        else -> InputSourceType.NONE
    }
}

fun getDirectory(directoryName: String = ""): String =
    File("").absoluteFile.absolutePath + "/src/main/${directoryName.lowercase()}/"

fun isInternetConnectionAvailable(): Boolean = try {
    executeBashCommandAndReturnOutput(arrayOf("ping", "-c", "1", "google.com")).isNotEmpty()
} catch (e: IOException) {
    false
}

fun generateVulnerabilityReportAsPDF(services: List<Service>?, dockerNetworkName: String = "") {
    val writer = PdfWriter(getDirectory("resources") + "output.pdf")
    val doc = Document(com.itextpdf.kernel.pdf.PdfDocument(writer))
    if (dockerNetworkName.isNotEmpty()) doc.add(
        Paragraph("Docker Network: $dockerNetworkName\n").setBold().setFontSize(15f)
    )
    services?.forEach { service ->
        doc.add(generateServiceInformationParagraph(service))
        doc.add(generateVulnerabilityDetailsTable(service))
        doc.add(Paragraph("\n"))
    }
    doc.add(
        Paragraph("Developed by Parsamlm").setItalic().setBold().setFontSize(10f)
            .setAction(com.itextpdf.kernel.pdf.action.PdfAction.createURI("https://github.com/parsamlm")).setUnderline()
            .setTextAlignment(com.itextpdf.layout.properties.TextAlignment.CENTER)
    )
    doc.close()
}

private fun generateServiceInformationParagraph(service: Service): Paragraph {
    val serviceInfo = Paragraph()
    service.url?.let { url ->
        serviceInfo.add(" ")
            .add(Paragraph(url).setBold().setAction(com.itextpdf.kernel.pdf.action.PdfAction.createURI(url)))
    }
    serviceInfo.add(" - ${service.type} (version: ${service.version})")
    return serviceInfo
}

private fun generateVulnerabilityDetailsTable(service: Service): Table {
    val table = Table(UnitValue.createPercentArray(floatArrayOf(1f, 1f, 1f))).useAllAvailableWidth()
    table.addHeaderCell(Cell().add(Paragraph("Vulnerability").setBold()))
    table.addHeaderCell(Cell().add(Paragraph("Description").setBold()))
    table.addHeaderCell(Cell().add(Paragraph("Severity").setBold()))

    service.vulnerabilities?.sortedBy { it.cve.metrics?.cvssMetricV2?.first()?.baseSeverity }
        ?.forEach { vulnerability ->
            val severity = vulnerability.cve.metrics?.cvssMetricV2?.first()?.baseSeverity ?: " "
            table.addCell(createSeverityBasedCellWithCVELink(vulnerability.cve.id, severity))
            table.addCell(
                createSeverityBasedCellWithBackground(
                    vulnerability.cve.descriptions?.first()?.value,
                    severity
                )
            )
            table.addCell(createSeverityBasedCellWithBackground(severity, severity))
        }
    return table
}

private fun createSeverityBasedCellWithBackground(content: String?, severity: String): Cell {
    val cell = Cell().add(Paragraph(content))
    when (severity) {
        "HIGH" -> cell.setBackgroundColor(ColorConstants.RED, 0.3f)
        "MEDIUM" -> cell.setBackgroundColor(ColorConstants.ORANGE, 0.3f)
        "LOW" -> cell.setBackgroundColor(ColorConstants.GREEN, 0.3f)
        else -> cell.setBackgroundColor(ColorConstants.WHITE)
    }
    return cell
}

private fun createSeverityBasedCellWithCVELink(cveID: String, severity: String): Cell {
    val cell =
        Cell().add(Paragraph(cveID).setAction(com.itextpdf.kernel.pdf.action.PdfAction.createURI("https://nvd.nist.gov/vuln/detail/$cveID")))
            .setFontColor(ColorConstants.BLUE)
    when (severity) {
        "HIGH" -> cell.setBackgroundColor(ColorConstants.RED, 0.3f)
        "MEDIUM" -> cell.setBackgroundColor(ColorConstants.ORANGE, 0.3f)
        "LOW" -> cell.setBackgroundColor(ColorConstants.GREEN, 0.3f)
        else -> cell.setBackgroundColor(ColorConstants.WHITE)
    }
    return cell
}